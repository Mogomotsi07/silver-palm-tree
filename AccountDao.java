import java.math.BigDecimal;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.*;

public final class AccountDao {
    public static void save(Account acc, String ownerId) {
        String sql = "MERGE INTO account VALUES (?,?,?,?,?,?)";
        try (Connection c = JdbcConnection.get(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, acc.getAccountNumber());
            ps.setString(2, ownerId);
            ps.setBigDecimal(3, BigDecimal.valueOf(acc.getBalance()));
            String t = acc instanceof SavingsAccount ? "SAVINGS" :
                    acc instanceof InvestmentAccount ? "INVESTMENT" : "CHEQUE";
            ps.setString(4, t);
            if (acc instanceof ChequeAccount ch) {
                ps.setString(5, ch.getEmployer());
                ps.setString(6, ch.getEmployerAddress());
            } else {
                ps.setString(5, null);
                ps.setString(6, null);
            }
            ps.executeUpdate();
            saveHistory(acc);
        } catch (SQLException e) { throw new RuntimeException(e); }

    }

    public static List<Account> findByOwner(String ownerId) {
        String sql = "SELECT * FROM account WHERE owner_id=?";
        try (Connection c = JdbcConnection.get(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, ownerId);
            ResultSet rs = ps.executeQuery();
            List<Account> list = new ArrayList<>();
            while (rs.next()) list.add(rebuild(rs));
            return list;
        } catch (SQLException e) { throw new RuntimeException(e); }
    }

    private static Account rebuild(ResultSet rs) throws SQLException {
        String num = rs.getString("account_number");
        double bal = rs.getDouble("balance");
        String type = rs.getString("type");
        Account acc = switch (type) {
            case "SAVINGS"    -> new SavingsAccount();
            case "INVESTMENT" -> new InvestmentAccount();
            default           -> new ChequeAccount(rs.getString("employer"), rs.getString("employer_addr"));
        };
        // reflect balance
        acc.deposit(bal);
        // overwrite autogenerated number
        reflectPrivate(acc, "accountNumber", num);
        return acc;
    }

    /* ---------- TRANSACTION HISTORY ---------- */
    private static void saveHistory(Account acc) {
        String sql = "DELETE FROM transaction WHERE account_number=?";
        try (Connection c = JdbcConnection.get(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, acc.getAccountNumber());
            ps.executeUpdate();
        } catch (SQLException ignore) {}

        sql = "INSERT INTO transaction (account_number,tx_time,tx_type,amount,balance_after) VALUES (?,?,?,?,?)";
        try (Connection c = JdbcConnection.get(); PreparedStatement ps = c.prepareStatement(sql)) {
            for (String line : acc.getHistory()) {
                /* parse: 2025-11-08 14:23:10 | Deposit: +100.00 | Balance=150.00 */
                String[] p = line.split(" \\| ");
                LocalDateTime dt = LocalDateTime.parse(p[0], java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
                String[] left = p[1].split(": ");
                double amt  = Double.parseDouble(left[1]);
                double bal  = Double.parseDouble(p[2].replace("Balance=", ""));
                ps.setString(1, acc.getAccountNumber());
                ps.setTimestamp(2, Timestamp.valueOf(dt));
                ps.setString(3, left[0]);   // Deposit / Withdraw
                ps.setBigDecimal(4, BigDecimal.valueOf(amt));
                ps.setBigDecimal(5, BigDecimal.valueOf(bal));
                ps.addBatch();
            }
            ps.executeBatch();
        } catch (SQLException e) { throw new RuntimeException(e); }
    }

    public static void loadHistory(Account acc) {
        String sql = "SELECT * FROM transaction WHERE account_number=? ORDER BY tx_time";
        try (Connection c = JdbcConnection.get(); PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, acc.getAccountNumber());
            ResultSet rs = ps.executeQuery();
            while (rs.next()) {
                String l = String.format("%s | %s: %.2f | Balance=%.2f",
                        rs.getTimestamp("tx_time").toLocalDateTime()
                                .format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")),
                        rs.getString("tx_type"),
                        rs.getBigDecimal("amount").doubleValue(),
                        rs.getBigDecimal("balance_after").doubleValue());
                acc.getHistory().add(l);
            }
        } catch (SQLException e) { throw new RuntimeException(e); }
    }

    /* helper to overwrite private final fields via reflection */
    private static void reflectPrivate(Object o, String field, Object val) {
        try {
            java.lang.reflect.Field f = o.getClass().getSuperclass().getDeclaredField(field);
            f.setAccessible(true);
            java.lang.reflect.Field modifiers = java.lang.reflect.Field.class.getDeclaredField("modifiers");
            modifiers.setAccessible(true);
            modifiers.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL);
            f.set(o, val);
        } catch (Exception e) { throw new RuntimeException(e); }
    }
}